{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww28600\viewh18000\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Thought Questions\
\
1) I will create a fixed array of size n. I will use a random number generator to pick a value from 0-99999. I will then define my array so 50% of those values 3, 25% of those values 4 and so on. The user then randomly picks any element of the array and can determine how many coins they have. \
\
I want to pick something that has minimal storage and overhead. The array method is able to keep overhead and storage low, but I do not know if this is optimal. So yes, my technique bias will most likely bias the optimal outcome\
\
\
2) If you want to generate games that are not immediate wins, then the number of coins != the size of the board. If you create your board and there are n spaces and n coins, the game is over. In my program I decide to randomly generate some constant and multiply that constant by the number of coins (constant is bounded [2,5].\
\
\
3) The computer would be able to provide hints when it sees the game ended in min(n) moves. To try and ensure the game ends in n moves (what the computer was able to calculate through simulations), it can offer the moves that it used to finish the game through its simulations. Another good hint would be that through simulations, it can offer advice for what is a bad move. If any even or odd number move will put you at a disadvantage, it will recommend that. \
\
4) I would want to make sure that the computer is ALWAYS trying to get coins in a position that is ONE space away from the winning spot. If the computer forces the next player to make a move where you can only move 1,  then the computer wins. So the program must always make the move that is one away from winning. \
\
5) No, because I would still have to check to see if coins are stacked, and not check if the coins are passing. As long as we make sure coins don\'92t stack and coins are moving to the left, I don\'92t think there will be significant changes. The main method will still be the EXACT same, it will load in the same messages and the scanner will work in the same way. \
\
	}